<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>helix.AccumLogger.logger API documentation</title>
<meta name="description" content="Usage : â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helix.AccumLogger.logger</code></h1>
</header>
<section id="section-intro">
<p>Usage :</p>
<pre><code>Create an Accumulator using Custom accumulator imported from logger module
&gt;&gt;&gt; from helix.AccumLogger.logger import *
&gt;&gt;&gt; acc = spark.sparkContext.accumulator(dict(),CustomAccumulator())

Create a instance of Metric Registry
&gt;&gt;&gt; # ['id','Error Type','Error Message'] -&gt; Error Data Schema
&gt;&gt;&gt; # logger - &gt; Method Name , default value is logger
&gt;&gt;&gt; metrics = MetricRegistry(acc,['id','Error Type','Error Message'],'logger')

Now the metrics.logger() can be used to log the required metrics
Number of arguments passed must be equal to error data schema or else remaining values will be 
filled with null values resulting in inproper schema for that specific record in output DataFrame
&gt;&gt;&gt; metrics.logger(231,'valueError',"invalid literal for int() with base 10: 'a' ")

Get Metrics information as Dict
&gt;&gt;&gt; metrics.getErrorDict()
{(231, 'ValueError', "invalid literal for int() with base 10: 'a'")}

Get Metrics information as DataFrame
&gt;&gt;&gt; metrics.getErrorData(spark).show()
     +---+----------+--------------------+
     | id|Error Type|       Error Message|
     +---+----------+--------------------+
     |231|ValueError|invalid literal f...|
     +---+----------+--------------------+

We can use it as counter
Create a Counter accumulator from CustomAccumulator by specifing the 
&gt;&gt;&gt;accC = spark.sparkContext.accumulator(dict(),CustomAccumulator(DictAccumulatorMethod.COUNTER))

Now Register this accumulator with Metrics Registry
&gt;&gt;&gt;counter = MetricRegistry(accC)

Now counter.inc() can be used as counter

&gt;&gt;&gt; counter.inc('processed',1)
&gt;&gt;&gt; counter.inc('processed',2)

Use getCounterDict to get current accumulator values as python dict
&gt;&gt;&gt; counter.getCounterDict()
     {'processed': 3}
&gt;&gt;&gt; counter.inc('failed',2)
&gt;&gt;&gt; counter.inc('failed',4)
&gt;&gt;&gt; counter.getCounterDict()
    {'processed': 3, 'failed': 6}

Counter data be returned as DataFrame
&gt;&gt;&gt; counter.getCounterData(spark).show()
    +-----------+-----+
    |Measurement|count|
    +-----------+-----+
    |  processed|    3|
    |     failed|    6|
    +-----------+-----+
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Usage :
    
    Create an Accumulator using Custom accumulator imported from logger module
    &gt;&gt;&gt; from helix.AccumLogger.logger import *
    &gt;&gt;&gt; acc = spark.sparkContext.accumulator(dict(),CustomAccumulator())
    
    Create a instance of Metric Registry
    &gt;&gt;&gt; # [&#39;id&#39;,&#39;Error Type&#39;,&#39;Error Message&#39;] -&gt; Error Data Schema
    &gt;&gt;&gt; # logger - &gt; Method Name , default value is logger
    &gt;&gt;&gt; metrics = MetricRegistry(acc,[&#39;id&#39;,&#39;Error Type&#39;,&#39;Error Message&#39;],&#39;logger&#39;)
    
    Now the metrics.logger() can be used to log the required metrics
    Number of arguments passed must be equal to error data schema or else remaining values will be 
    filled with null values resulting in inproper schema for that specific record in output DataFrame
    &gt;&gt;&gt; metrics.logger(231,&#39;valueError&#39;,&#34;invalid literal for int() with base 10: &#39;a&#39; &#34;)
    
    Get Metrics information as Dict
    &gt;&gt;&gt; metrics.getErrorDict()
    {(231, &#39;ValueError&#39;, &#34;invalid literal for int() with base 10: &#39;a&#39;&#34;)}
    
    Get Metrics information as DataFrame
    &gt;&gt;&gt; metrics.getErrorData(spark).show()
         +---+----------+--------------------+
         | id|Error Type|       Error Message|
         +---+----------+--------------------+
         |231|ValueError|invalid literal f...|
         +---+----------+--------------------+
         
    We can use it as counter
    Create a Counter accumulator from CustomAccumulator by specifing the 
    &gt;&gt;&gt;accC = spark.sparkContext.accumulator(dict(),CustomAccumulator(DictAccumulatorMethod.COUNTER))
    
    Now Register this accumulator with Metrics Registry
    &gt;&gt;&gt;counter = MetricRegistry(accC)
    
    Now counter.inc() can be used as counter 
    
    &gt;&gt;&gt; counter.inc(&#39;processed&#39;,1)
    &gt;&gt;&gt; counter.inc(&#39;processed&#39;,2)
    
    Use getCounterDict to get current accumulator values as python dict
    &gt;&gt;&gt; counter.getCounterDict()
         {&#39;processed&#39;: 3}
    &gt;&gt;&gt; counter.inc(&#39;failed&#39;,2)
    &gt;&gt;&gt; counter.inc(&#39;failed&#39;,4)
    &gt;&gt;&gt; counter.getCounterDict()
        {&#39;processed&#39;: 3, &#39;failed&#39;: 6}
        
    Counter data be returned as DataFrame
    &gt;&gt;&gt; counter.getCounterData(spark).show()
        +-----------+-----+
        |Measurement|count|
        +-----------+-----+
        |  processed|    3|
        |     failed|    6|
        +-----------+-----+
        
&#34;&#34;&#34;
from pyspark import AccumulatorParam
from typing import List, Dict
from pyspark.sql import SparkSession
from pyspark.sql import DataFrame
from pyspark.accumulators import Accumulator
from enum import Enum


class DictAccumulatorMethod(Enum):
    &#34;&#34;&#34;
    Dictionary Methods to update the keys accordingly 
    &#34;&#34;&#34;

    &#34;&#34;&#34; REPLACE either adds a new key value or replace the value of existing key &#34;&#34;&#34;
    REPLACE = lambda d, key, value: d.update({key: value})
    &#34;&#34;&#34; KEEP either adds a new key value or keeps the value of existing key &#34;&#34;&#34;
    KEEP = lambda d, key, value: d.update({key: d.get(key, value)})
    &#34;&#34;&#34; ADD adds the value to existing value or add new key value &#34;&#34;&#34;
    ADD = lambda d, key, value: d.update({key: (d[key] + value) if key in d else value})
    &#34;&#34;&#34; LIST add new value to the list pertaining to given key &#34;&#34;&#34;
    LIST = lambda d, key, value: d.update({key: d.get(key, []) + value})
    &#34;&#34;&#34; SET add new value to the set pertaining to given key &#34;&#34;&#34;
    SET = lambda d, key, value: d.update(
        {key: list(set(d.get(key, set([]))).union(value))}
    )
    &#34;&#34;&#34;COUNTER is used to increase the counter of the passed tag&#34;&#34;&#34;
    COUNTER = lambda d, key, value: d.update(
        {key: (d[key] + value) if key in d else value}
    )


class CustomAccumulator(AccumulatorParam):
    &#34;&#34;&#34;
    Custom pyspark accumulator to collect the error logs, Number Counters and add it 
    to the existing accumulator contents
    &#34;&#34;&#34;

    def __init__(self, dict_accumulator_method=DictAccumulatorMethod.LIST):
        &#34;&#34;&#34;
        Initialize accumulator with specific type
        :param dict_accumulator_method: method which defines combining values 
        based on type
        &#34;&#34;&#34;
        self.method = dict_accumulator_method

    def zero(self, init_value: dict):
        return init_value

    def addInPlace(self, v1: dict, v2: dict) -&gt; dict:
        for key, value in v2.items():
            self.method(v1, key, value)
        return v1


class MetricRegistry:
    &#34;&#34;&#34;
    Accumulator to add the log data and to retrieve the contents of the 
    accumulator
    @param accumulator - created Custom Error Accumulator
    @param schema      - Schema of the Error Data Dataframe
    &#34;&#34;&#34;

    def __init__(
        self, accumulator: Accumulator, schema: List = None, Acctype: str = None
    ):
        self.accumulator = accumulator
        self.schema = schema
        self.Acctype = Acctype

    def inc(self, name: str, count: int=1):
        &#34;&#34;&#34;
        This method can only be used with COUNTER Method 
        &#34;&#34;&#34;
        self.accumulator += {name: count}

    def logger(self, *args):
        &#34;&#34;&#34;
        Adds passed values to the existing accumulator
        Number of arguments passed must meet with 
        Type will be logger by default if nothing is passed during initialization
        &#34;&#34;&#34;
        accType = &#34;logger&#34;
        values = list(args)
        if self.Acctype is None:
            accType = self.Acctype
        if len(self.schema) &gt; len(list(args)):
            values = list(args) + [&#34;&#34;] * (len(self.schema) - len(list(args)))
        self.accumulator += {accType: [values]}

    def getCounterDict(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Retrieves content of the accumulator
        &#34;&#34;&#34;
        return self.accumulator.value

    def getErrorDict(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Retrieves content of the accumulator
        &#34;&#34;&#34;
        return self.accumulator.value

    def getCounterData(self, spark: SparkSession, schema: List = None) -&gt; DataFrame:
        &#34;&#34;&#34;
        Returns Counter Accumulator Data as DataFrame, Schema can be passed
        Default schema will be [ Measurement , count ]
        &#34;&#34;&#34;
        if schema is None:
            schema = [&#34;Measurement&#34;, &#34;count&#34;]
        return spark.createDataFrame(
            list(map(list, self.accumulator.value.items())), schema
        )

    def getErrorData(self, spark: SparkSession) -&gt; DataFrame:
        &#34;&#34;&#34;
        Returns content of accumulator as a spark dataframe
        &#34;&#34;&#34;
        return spark.createDataFrame(self.accumulator.value[&#34;logger&#34;], self.schema)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="helix.AccumLogger.logger.CustomAccumulator"><code class="flex name class">
<span>class <span class="ident">CustomAccumulator</span></span>
<span>(</span><span>dict_accumulator_method=&lt;function DictAccumulatorMethod.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom pyspark accumulator to collect the error logs, Number Counters and add it
to the existing accumulator contents</p>
<p>Initialize accumulator with specific type
:param dict_accumulator_method: method which defines combining values
based on type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomAccumulator(AccumulatorParam):
    &#34;&#34;&#34;
    Custom pyspark accumulator to collect the error logs, Number Counters and add it 
    to the existing accumulator contents
    &#34;&#34;&#34;

    def __init__(self, dict_accumulator_method=DictAccumulatorMethod.LIST):
        &#34;&#34;&#34;
        Initialize accumulator with specific type
        :param dict_accumulator_method: method which defines combining values 
        based on type
        &#34;&#34;&#34;
        self.method = dict_accumulator_method

    def zero(self, init_value: dict):
        return init_value

    def addInPlace(self, v1: dict, v2: dict) -&gt; dict:
        for key, value in v2.items():
            self.method(v1, key, value)
        return v1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pyspark.accumulators.AccumulatorParam</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="helix.AccumLogger.logger.CustomAccumulator.addInPlace"><code class="name flex">
<span>def <span class="ident">addInPlace</span></span>(<span>self, v1:Â dict, v2:Â dict) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Add two values of the accumulator's data type, returning a new value;
for efficiency, can also update <code>value1</code> in place and return it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addInPlace(self, v1: dict, v2: dict) -&gt; dict:
    for key, value in v2.items():
        self.method(v1, key, value)
    return v1</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.CustomAccumulator.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>self, init_value:Â dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide a "zero value" for the type, compatible in dimensions with the
provided <code>value</code> (e.g., a zero vector)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zero(self, init_value: dict):
    return init_value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod"><code class="flex name class">
<span>class <span class="ident">DictAccumulatorMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Dictionary Methods to update the keys accordingly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictAccumulatorMethod(Enum):
    &#34;&#34;&#34;
    Dictionary Methods to update the keys accordingly 
    &#34;&#34;&#34;

    &#34;&#34;&#34; REPLACE either adds a new key value or replace the value of existing key &#34;&#34;&#34;
    REPLACE = lambda d, key, value: d.update({key: value})
    &#34;&#34;&#34; KEEP either adds a new key value or keeps the value of existing key &#34;&#34;&#34;
    KEEP = lambda d, key, value: d.update({key: d.get(key, value)})
    &#34;&#34;&#34; ADD adds the value to existing value or add new key value &#34;&#34;&#34;
    ADD = lambda d, key, value: d.update({key: (d[key] + value) if key in d else value})
    &#34;&#34;&#34; LIST add new value to the list pertaining to given key &#34;&#34;&#34;
    LIST = lambda d, key, value: d.update({key: d.get(key, []) + value})
    &#34;&#34;&#34; SET add new value to the set pertaining to given key &#34;&#34;&#34;
    SET = lambda d, key, value: d.update(
        {key: list(set(d.get(key, set([]))).union(value))}
    )
    &#34;&#34;&#34;COUNTER is used to increase the counter of the passed tag&#34;&#34;&#34;
    COUNTER = lambda d, key, value: d.update(
        {key: (d[key] + value) if key in d else value}
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.ADD"><code class="name flex">
<span>def <span class="ident">ADD</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">ADD = lambda d, key, value: d.update({key: (d[key] + value) if key in d else value})</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.COUNTER"><code class="name flex">
<span>def <span class="ident">COUNTER</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">COUNTER = lambda d, key, value: d.update(
    {key: (d[key] + value) if key in d else value}
)</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.KEEP"><code class="name flex">
<span>def <span class="ident">KEEP</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">KEEP = lambda d, key, value: d.update({key: d.get(key, value)})</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.LIST"><code class="name flex">
<span>def <span class="ident">LIST</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">LIST = lambda d, key, value: d.update({key: d.get(key, []) + value})</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.REPLACE"><code class="name flex">
<span>def <span class="ident">REPLACE</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">REPLACE = lambda d, key, value: d.update({key: value})</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.DictAccumulatorMethod.SET"><code class="name flex">
<span>def <span class="ident">SET</span></span>(<span>d, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">SET = lambda d, key, value: d.update(
    {key: list(set(d.get(key, set([]))).union(value))}
)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry"><code class="flex name class">
<span>class <span class="ident">MetricRegistry</span></span>
<span>(</span><span>accumulator:Â pyspark.accumulators.Accumulator, schema:Â ListÂ =Â None, Acctype:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulator to add the log data and to retrieve the contents of the
accumulator
@param accumulator - created Custom Error Accumulator
@param schema
- Schema of the Error Data Dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricRegistry:
    &#34;&#34;&#34;
    Accumulator to add the log data and to retrieve the contents of the 
    accumulator
    @param accumulator - created Custom Error Accumulator
    @param schema      - Schema of the Error Data Dataframe
    &#34;&#34;&#34;

    def __init__(
        self, accumulator: Accumulator, schema: List = None, Acctype: str = None
    ):
        self.accumulator = accumulator
        self.schema = schema
        self.Acctype = Acctype

    def inc(self, name: str, count: int=1):
        &#34;&#34;&#34;
        This method can only be used with COUNTER Method 
        &#34;&#34;&#34;
        self.accumulator += {name: count}

    def logger(self, *args):
        &#34;&#34;&#34;
        Adds passed values to the existing accumulator
        Number of arguments passed must meet with 
        Type will be logger by default if nothing is passed during initialization
        &#34;&#34;&#34;
        accType = &#34;logger&#34;
        values = list(args)
        if self.Acctype is None:
            accType = self.Acctype
        if len(self.schema) &gt; len(list(args)):
            values = list(args) + [&#34;&#34;] * (len(self.schema) - len(list(args)))
        self.accumulator += {accType: [values]}

    def getCounterDict(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Retrieves content of the accumulator
        &#34;&#34;&#34;
        return self.accumulator.value

    def getErrorDict(self) -&gt; List[Dict]:
        &#34;&#34;&#34;
        Retrieves content of the accumulator
        &#34;&#34;&#34;
        return self.accumulator.value

    def getCounterData(self, spark: SparkSession, schema: List = None) -&gt; DataFrame:
        &#34;&#34;&#34;
        Returns Counter Accumulator Data as DataFrame, Schema can be passed
        Default schema will be [ Measurement , count ]
        &#34;&#34;&#34;
        if schema is None:
            schema = [&#34;Measurement&#34;, &#34;count&#34;]
        return spark.createDataFrame(
            list(map(list, self.accumulator.value.items())), schema
        )

    def getErrorData(self, spark: SparkSession) -&gt; DataFrame:
        &#34;&#34;&#34;
        Returns content of accumulator as a spark dataframe
        &#34;&#34;&#34;
        return spark.createDataFrame(self.accumulator.value[&#34;logger&#34;], self.schema)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="helix.AccumLogger.logger.MetricRegistry.getCounterData"><code class="name flex">
<span>def <span class="ident">getCounterData</span></span>(<span>self, spark:Â pyspark.sql.session.SparkSession, schema:Â ListÂ =Â None) â€‘>Â pyspark.sql.dataframe.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Counter Accumulator Data as DataFrame, Schema can be passed
Default schema will be [ Measurement , count ]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCounterData(self, spark: SparkSession, schema: List = None) -&gt; DataFrame:
    &#34;&#34;&#34;
    Returns Counter Accumulator Data as DataFrame, Schema can be passed
    Default schema will be [ Measurement , count ]
    &#34;&#34;&#34;
    if schema is None:
        schema = [&#34;Measurement&#34;, &#34;count&#34;]
    return spark.createDataFrame(
        list(map(list, self.accumulator.value.items())), schema
    )</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry.getCounterDict"><code class="name flex">
<span>def <span class="ident">getCounterDict</span></span>(<span>self) â€‘>Â List[Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves content of the accumulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCounterDict(self) -&gt; List[Dict]:
    &#34;&#34;&#34;
    Retrieves content of the accumulator
    &#34;&#34;&#34;
    return self.accumulator.value</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry.getErrorData"><code class="name flex">
<span>def <span class="ident">getErrorData</span></span>(<span>self, spark:Â pyspark.sql.session.SparkSession) â€‘>Â pyspark.sql.dataframe.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns content of accumulator as a spark dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getErrorData(self, spark: SparkSession) -&gt; DataFrame:
    &#34;&#34;&#34;
    Returns content of accumulator as a spark dataframe
    &#34;&#34;&#34;
    return spark.createDataFrame(self.accumulator.value[&#34;logger&#34;], self.schema)</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry.getErrorDict"><code class="name flex">
<span>def <span class="ident">getErrorDict</span></span>(<span>self) â€‘>Â List[Dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves content of the accumulator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getErrorDict(self) -&gt; List[Dict]:
    &#34;&#34;&#34;
    Retrieves content of the accumulator
    &#34;&#34;&#34;
    return self.accumulator.value</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>self, name:Â str, count:Â intÂ =Â 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This method can only be used with COUNTER Method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc(self, name: str, count: int=1):
    &#34;&#34;&#34;
    This method can only be used with COUNTER Method 
    &#34;&#34;&#34;
    self.accumulator += {name: count}</code></pre>
</details>
</dd>
<dt id="helix.AccumLogger.logger.MetricRegistry.logger"><code class="name flex">
<span>def <span class="ident">logger</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds passed values to the existing accumulator
Number of arguments passed must meet with
Type will be logger by default if nothing is passed during initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logger(self, *args):
    &#34;&#34;&#34;
    Adds passed values to the existing accumulator
    Number of arguments passed must meet with 
    Type will be logger by default if nothing is passed during initialization
    &#34;&#34;&#34;
    accType = &#34;logger&#34;
    values = list(args)
    if self.Acctype is None:
        accType = self.Acctype
    if len(self.schema) &gt; len(list(args)):
        values = list(args) + [&#34;&#34;] * (len(self.schema) - len(list(args)))
    self.accumulator += {accType: [values]}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helix.AccumLogger" href="index.html">helix.AccumLogger</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="helix.AccumLogger.logger.CustomAccumulator" href="#helix.AccumLogger.logger.CustomAccumulator">CustomAccumulator</a></code></h4>
<ul class="">
<li><code><a title="helix.AccumLogger.logger.CustomAccumulator.addInPlace" href="#helix.AccumLogger.logger.CustomAccumulator.addInPlace">addInPlace</a></code></li>
<li><code><a title="helix.AccumLogger.logger.CustomAccumulator.zero" href="#helix.AccumLogger.logger.CustomAccumulator.zero">zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod" href="#helix.AccumLogger.logger.DictAccumulatorMethod">DictAccumulatorMethod</a></code></h4>
<ul class="two-column">
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.ADD" href="#helix.AccumLogger.logger.DictAccumulatorMethod.ADD">ADD</a></code></li>
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.COUNTER" href="#helix.AccumLogger.logger.DictAccumulatorMethod.COUNTER">COUNTER</a></code></li>
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.KEEP" href="#helix.AccumLogger.logger.DictAccumulatorMethod.KEEP">KEEP</a></code></li>
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.LIST" href="#helix.AccumLogger.logger.DictAccumulatorMethod.LIST">LIST</a></code></li>
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.REPLACE" href="#helix.AccumLogger.logger.DictAccumulatorMethod.REPLACE">REPLACE</a></code></li>
<li><code><a title="helix.AccumLogger.logger.DictAccumulatorMethod.SET" href="#helix.AccumLogger.logger.DictAccumulatorMethod.SET">SET</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="helix.AccumLogger.logger.MetricRegistry" href="#helix.AccumLogger.logger.MetricRegistry">MetricRegistry</a></code></h4>
<ul class="two-column">
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.getCounterData" href="#helix.AccumLogger.logger.MetricRegistry.getCounterData">getCounterData</a></code></li>
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.getCounterDict" href="#helix.AccumLogger.logger.MetricRegistry.getCounterDict">getCounterDict</a></code></li>
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.getErrorData" href="#helix.AccumLogger.logger.MetricRegistry.getErrorData">getErrorData</a></code></li>
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.getErrorDict" href="#helix.AccumLogger.logger.MetricRegistry.getErrorDict">getErrorDict</a></code></li>
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.inc" href="#helix.AccumLogger.logger.MetricRegistry.inc">inc</a></code></li>
<li><code><a title="helix.AccumLogger.logger.MetricRegistry.logger" href="#helix.AccumLogger.logger.MetricRegistry.logger">logger</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>